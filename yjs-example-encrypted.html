<!DOCTYPE html>
<html>
<head>
    <title>Y.js Encrypted Collaborative Editor</title>
    <script type="module">
        import * as Y from 'https://cdn.jsdelivr.net/npm/yjs@13.6.8/dist/yjs.mjs';
        import { CodemirrorBinding } from 'https://cdn.jsdelivr.net/npm/y-codemirror@3.0.1/dist/y-codemirror.mjs';
        window.Y = Y;
        window.CodemirrorBinding = CodemirrorBinding;
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <style>
        /* ... (same styles as before) ... */
        .room-key-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
        }
        .encrypted-badge {
            background: #4CAF50;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <h1>Y.js Encrypted Collaborative Editor</h1>
    <div class="container">
        <div class="sidebar">
            <h2>Rooms</h2>
            <input type="text" id="room-key" class="room-key-input" placeholder="Room encryption key (optional)">
            <button class="create-room" onclick="createNewRoom()">Create New Room</button>
            <div class="room-list" id="room-list">
                Loading rooms...
            </div>
        </div>
        <div class="editor-container">
            <h2>Room: <span id="current-room">Not connected</span></h2>
            <div id="editor"></div>
            <div class="status" id="connection-status">Connecting...</div>
            <div class="awareness-list" id="awareness-list">Users online: </div>
        </div>
    </div>

    <script type="module">
        // Wait for Y to be available
        setTimeout(async () => {
            const Y = window.Y;
            const CodemirrorBinding = window.CodemirrorBinding;
            
            if (!Y || !CodemirrorBinding) {
                console.error('Y.js or CodemirrorBinding not loaded');
                return;
            }

            let currentRoomId = null;
            let currentProvider = null;
            let currentDoc = null;
            let currentBinding = null;
            let currentKey = null;

            // Initialize CodeMirror
            const editor = CodeMirror(document.getElementById('editor'), {
                mode: 'text/plain',
                lineNumbers: true,
                theme: 'default',
                lineWrapping: true
            });

            // Encryption utilities
            const encryptionUtils = {
                async generateKey(password) {
                    const enc = new TextEncoder();
                    const keyMaterial = await window.crypto.subtle.importKey(
                        "raw",
                        enc.encode(password),
                        { name: "PBKDF2" },
                        false,
                        ["deriveBits", "deriveKey"]
                    );

                    return window.crypto.subtle.deriveKey(
                        {
                            name: "PBKDF2",
                            salt: enc.encode("y-js-collab"),
                            iterations: 100000,
                            hash: "SHA-256"
                        },
                        keyMaterial,
                        { name: "AES-GCM", length: 256 },
                        true,
                        ["encrypt", "decrypt"]
                    );
                },

                async encrypt(data, key) {
                    const iv = window.crypto.getRandomValues(new Uint8Array(12));
                    const enc = new TextEncoder();
                    
                    const encrypted = await window.crypto.subtle.encrypt(
                        {
                            name: "AES-GCM",
                            iv: iv
                        },
                        key,
                        typeof data === 'string' ? enc.encode(data) : data
                    );

                    const encryptedContent = new Uint8Array(encrypted);
                    const result = new Uint8Array(iv.length + encryptedContent.length);
                    result.set(iv);
                    result.set(encryptedContent, iv.length);
                    
                    return result;
                },

                async decrypt(data, key) {
                    const iv = data.slice(0, 12);
                    const content = data.slice(12);
                    
                    return await window.crypto.subtle.decrypt(
                        {
                            name: "AES-GCM",
                            iv: iv
                        },
                        key,
                        content
                    );
                }
            };

            // Create custom signaling provider with encryption support
            class CustomSignalingProvider {
                constructor(ydoc, roomId, encryptionKey = null) {
                    this.ydoc = ydoc;
                    this.roomId = roomId;
                    this.encryptionKey = encryptionKey;
                    this.ws = null;
                    this.peers = new Set();
                    this.awareness = new Y.Awareness(ydoc);
                    this.connect();

                    this.awareness.setLocalState({
                        user: {
                            name: 'User ' + ydoc.clientID,
                            color: userColor
                        }
                    });
                }

                async connect() {
                    this.ws = new WebSocket('ws://127.0.0.1:8081');
                    
                    this.ws.onopen = async () => {
                        updateStatus('Connected to signaling server');
                        
                        let joinPayload = {
                            user_id: this.ydoc.clientID,
                            user_color: userColor,
                            room_id: this.roomId,
                            encrypted_data: null
                        };

                        if (this.encryptionKey) {
                            const key = await encryptionUtils.generateKey(this.encryptionKey);
                            const encrypted = await encryptionUtils.encrypt('test', key);
                            joinPayload.encrypted_data = btoa(String.fromCharCode.apply(null, encrypted));
                        }

                        this.ws.send(JSON.stringify({ 
                            type: 'Join',
                            payload: joinPayload
                        }));

                        this.ws.send(JSON.stringify({ type: 'GetRooms' }));
                    };

                    this.ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.handleSignalingMessage(message);
                    };

                    this.ws.onerror = (error) => {
                        updateStatus('Signaling server error: ' + error.message);
                    };

                    this.ws.onclose = () => {
                        updateStatus('Disconnected from signaling server');
                        setTimeout(() => this.connect(), 5000);
                    };
                }

                async send(message) {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        if (this.encryptionKey && message.type === 'SyncUpdate') {
                            const key = await encryptionUtils.generateKey(this.encryptionKey);
                            const encrypted = await encryptionUtils.encrypt(new Uint8Array(message.payload.update), key);
                            message.payload.encrypted_data = btoa(String.fromCharCode.apply(null, encrypted));
                        }
                        this.ws.send(JSON.stringify(message));
                    }
                }

                async handleSignalingMessage(message) {
                    switch (message.type) {
                        case 'Join':
                            if (message.payload.room_id === this.roomId && 
                                message.payload.user_id !== this.ydoc.clientID) {
                                this.peers.add(message.payload.user_id);
                                updateAwarenessList();
                            }
                            break;
                        case 'SyncUpdate':
                            if (message.payload.room_id === this.roomId) {
                                if (this.encryptionKey && message.payload.encrypted_data) {
                                    const key = await encryptionUtils.generateKey(this.encryptionKey);
                                    const encryptedData = Uint8Array.from(atob(message.payload.encrypted_data), c => c.charCodeAt(0));
                                    const decrypted = await encryptionUtils.decrypt(encryptedData, key);
                                    Y.applyUpdate(this.ydoc, new Uint8Array(decrypted));
                                } else if (!this.encryptionKey) {
                                    Y.applyUpdate(this.ydoc, new Uint8Array(message.payload.update));
                                }
                            }
                            break;
                        case 'RoomList':
                            updateRoomList(message.payload.rooms);
                            break;
                    }
                }

                disconnect() {
                    if (this.ws) {
                        this.ws.send(JSON.stringify({
                            type: 'LeaveRoom',
                            payload: { room_id: this.roomId }
                        }));
                        this.ws.close();
                    }
                }
            }

            const userColor = '#' + Math.floor(Math.random()*16777215).toString(16);

            function updateStatus(message) {
                document.getElementById('connection-status').textContent = message;
            }

            function updateAwarenessList() {
                if (!currentProvider) return;
                
                const list = document.getElementById('awareness-list');
                list.innerHTML = 'Users online: ' + currentProvider.peers.size;
                currentProvider.peers.forEach(peerId => {
                    const userElement = document.createElement('span');
                    userElement.className = 'user-cursor';
                    userElement.style.backgroundColor = userColor;
                    userElement.textContent = `User ${peerId}`;
                    list.appendChild(userElement);
                });
            }

            function updateRoomList(rooms) {
                const list = document.getElementById('room-list');
                list.innerHTML = '';
                
                rooms.forEach(room => {
                    const roomElement = document.createElement('div');
                    roomElement.className = 'room-item' + (room.room_id === currentRoomId ? ' active' : '');
                    roomElement.textContent = `Room ${room.room_id} (${room.peer_count} users)`;
                    if (room.encrypted) {
                        const badge = document.createElement('span');
                        badge.className = 'encrypted-badge';
                        badge.textContent = 'ðŸ”’ Encrypted';
                        roomElement.appendChild(badge);
                    }
                    roomElement.onclick = () => {
                        const key = document.getElementById('room-key').value;
                        joinRoom(room.room_id, room.encrypted ? key : null);
                    };
                    list.appendChild(roomElement);
                });
            }

            window.createNewRoom = () => {
                const roomId = 'room-' + Math.random().toString(36).substr(2, 9);
                const key = document.getElementById('room-key').value;
                joinRoom(roomId, key || null);
            };

            async function joinRoom(roomId, key = null) {
                if (currentProvider) {
                    currentProvider.disconnect();
                    currentDoc.destroy();
                }

                currentRoomId = roomId;
                currentKey = key;
                document.getElementById('current-room').textContent = roomId + (key ? ' ðŸ”’' : '');

                currentDoc = new Y.Doc();
                const ytext = currentDoc.getText('codemirror');

                currentProvider = new CustomSignalingProvider(currentDoc, roomId, key);

                if (currentBinding) {
                    currentBinding.destroy();
                }
                currentBinding = new CodemirrorBinding(ytext, editor, currentProvider.awareness);

                currentDoc.on('update', (update) => {
                    currentProvider.send({
                        type: 'SyncUpdate',
                        payload: {
                            update: Array.from(update),
                            room_id: roomId
                        }
                    });
                });

                updateStatus('Connected to ' + (key ? 'encrypted ' : '') + 'room: ' + roomId);
            }

            window.addEventListener('unload', () => {
                if (currentProvider) {
                    currentProvider.disconnect();
                    currentDoc.destroy();
                }
            });

            joinRoom('default-room');
        }, 1000);
    </script>
</body>
</html>
